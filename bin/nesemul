#!/usr/bin/env ruby

root = File.expand_path("../..", __FILE__)
require "sdl"
require 'json'
require "#{root}/lib/ppu.rb"
require "#{root}/lib/cpu.rb"
require "#{root}/lib/opcodes.rb"
require "#{root}/lib/bitwise.rb"

rom = File.open(ARGV[0]).read.bytes.to_a

$compteur_cycles = 0
$cpu = Cpu.new(rom)
$ppu = $cpu.ppu
$cpu.reset_rom


def ppu_exec(cycles)
    (3*cycles).times do

		$ppu.draw_screen

		if [$ppu.x,$ppu.y] == [0,-1] or $compteur_cycles == 0
			#puts "CLEARING VBLANK !!!"
			$ppu.clear_vblank
		end

        $compteur_cycles += 1

		if [$ppu.x,$ppu.y] == [0,240] or $compteur_cycles > 5000
			# puts "SETTING VBLANK !!!"
			$ppu.set_vblank
			$ppu.screen.flip
			# puts "REFRESH !!!" 
			if $ppu.registers[0x2000].bit?(7) == 1
              # puts "NMI INTERRUPT !!!"
              $cpu.nmi_interrupt
            end
			$compteur_cycles = 0
	    end
        
	end
end

while true
	nb_args = OPCODES[$cpu.ram[$cpu.cpu[:compteur]]][:len].to_i
	$cpu.cpu[:compteur_new] += nb_args
	#puts $cpu.ram.count(nil) if $cpu.ram.count(nil) !=0
	$cpu.send OPCODES[$cpu.ram[$cpu.cpu[:compteur]]][:opcodes].downcase, $cpu.ram[$cpu.cpu[:compteur]], $cpu.ram[$cpu.cpu[:compteur]+1], $cpu.ram[$cpu.cpu[:compteur]+2]
	ppu_exec(OPCODES[$cpu.ram[$cpu.cpu[:compteur]]][:tim].to_i)
	#puts "#{$cpu.ram[$cpu.cpu[:compteur]+1]}, #{$cpu.ram[$cpu.cpu[:compteur]+2]}"
	#puts "Nom de l'instruct : #{OPCODES[$cpu.ram[$cpu.cpu[:compteur]]][:opcodes]}"
	#puts "Etat du cpu apres l'instruction #{$cpu.cpu}"
	#puts "___________________________________________________________________________________________\n"
	#puts "#{$cpu.cpu[:A]},#{$cpu.ram[52692]},#{$cpu.ram[52692+1]}"
	$cpu.cpu[:compteur] = $cpu.cpu[:compteur_new]
end

